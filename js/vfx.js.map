{
  "version": 3,
  "sources": ["../../src/js/vfx.ts"],
  "sourcesContent": ["const vertexShader = `\nprecision mediump float;\n\nattribute vec2 a_position;\n\nvarying vec2 v_texCoord;\n\nvoid main() {\n    v_texCoord = vec2(a_position.x, 1.0 - a_position.y);\n    gl_Position = vec4((a_position - vec2(0.5)) * vec2(2.0), 0.0, 1.0);\n}\n`;\n\nconst fragmentShader = `\nprecision highp float;\n\nvarying vec2 v_texCoord;\nuniform vec2 u_resolution;\nuniform float u_time;\nuniform float u_dpi;\nuniform vec3 u_darkSquare;\nuniform vec3 u_lightSquare;\n\nfloat sdBox( in vec2 p, in vec2 rad )\n{\n    p = abs(p) - rad;\n    return max(p.x, p.y);\n}\n\nvoid main() {\n    float checker_size = 48.0 * u_dpi;\n\n    const float SPEED = 0.1;\n    const float TAU = 6.283185307179586;\n    vec2 fragCoord = v_texCoord * u_resolution;\n\n    // Center the checkerboard\n    vec2 offset = (u_resolution - (floor((u_resolution / vec2(checker_size)) + 0.5) * vec2(checker_size))) * -0.5;\n\n    vec2 square_coord = mod(fragCoord + offset, vec2(checker_size));\n\n    vec2 square_index = floor((fragCoord + offset) / vec2(checker_size));\n\n    bool checker_fill = mod(square_index.x, 2.0) == mod(square_index.y, 2.0);\n\n    // Diagonal rotation offset\n    // float rot_add = (fragCoord.x + fragCoord.y) * 0.0005;\n\n    // Radial rotation offset (from center)\n    // float rot_add = distance(fragCoord + offset, u_resolution / 2.0) * -0.00125;\n    float rot_add = fragCoord.x * -0.001 / u_dpi;\n\n    float rotation_turns = mod(-u_time * SPEED + rot_add, 0.5);\n\n    bool flip_fill = mod(rotation_turns, 0.5) >= 0.25;\n\n    float rotation_angle = rotation_turns * TAU;\n    mat2 rotation_matrix = mat2(cos(rotation_angle), -sin(rotation_angle), sin(rotation_angle), cos(rotation_angle));\n\n    const float CHECKER_SHRINK = 1.0;\n    //float CHECKER_SHRINK = sin(fragCoord.y * 0.01 + u_time * 1.0) * 5.0 + 1.0;\n\n    float box_coverage_center = sdBox((square_coord - vec2(checker_size / 2.0)) * rotation_matrix, vec2((checker_size - CHECKER_SHRINK) / 2.0));\n    float box_coverage_top = sdBox((square_coord - vec2(checker_size / 2.0, checker_size * 1.5)) * rotation_matrix, vec2((checker_size - CHECKER_SHRINK) / 2.0));\n    float box_coverage_right = sdBox((square_coord - vec2(checker_size * 1.5, checker_size / 2.0)) * rotation_matrix, vec2((checker_size - CHECKER_SHRINK) / 2.0));\n    float box_coverage_bottom = sdBox((square_coord - vec2(checker_size / 2.0, checker_size * -0.5)) * rotation_matrix, vec2((checker_size - CHECKER_SHRINK) / 2.0));\n    float box_coverage_left = sdBox((square_coord - vec2(checker_size * -0.5, checker_size / 2.0)) * rotation_matrix, vec2((checker_size - CHECKER_SHRINK) / 2.0));\n\n    float box_coverage_adjacent = min(min(min(box_coverage_top, box_coverage_right), box_coverage_bottom), box_coverage_left);\n\n    float coverage = checker_fill ^^ flip_fill ? box_coverage_adjacent : box_coverage_center;\n    coverage = clamp(flip_fill ? CHECKER_SHRINK - coverage : coverage, 0.0, 1.0);\n\n    vec3 color = mix(u_lightSquare, u_darkSquare, vec3(coverage));\n    gl_FragColor = vec4(color, 1.0);\n}\n`;\n\nconst createShader = (gl: WebGLRenderingContext, source: string, type: number): WebGLShader => {\n    const shader = gl.createShader(type);\n    if (!shader) throw new Error('Could not create shader.');\n    gl.shaderSource(shader, source);\n    gl.compileShader(shader);\n\n    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n        const info = gl.getShaderInfoLog(shader) ?? '';\n        throw new Error('Could not compile WebGL program. \\n' + info);\n    }\n\n    return shader;\n};\n\nclass Shader {\n    private gl: WebGLRenderingContext;\n    public program: WebGLProgram;\n    // TODO: strongly type these\n    public uniforms: Record<string, WebGLUniformLocation>;\n    public attribs: Record<string, number>;\n\n    public constructor(gl: WebGLRenderingContext, vertex: string, fragment: string) {\n        const vertexShader = createShader(gl, vertex, gl.VERTEX_SHADER);\n        const fragmentShader = createShader(gl, fragment, gl.FRAGMENT_SHADER);\n        const program = gl.createProgram();\n        if (!program) throw new Error('Could not create program');\n        gl.attachShader(program, vertexShader);\n        gl.attachShader(program, fragmentShader);\n        gl.linkProgram(program);\n\n        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n            const info = gl.getProgramInfoLog(program) ?? '';\n            throw new Error('Could not compile WebGL program. \\n' + info);\n        }\n        this.gl = gl;\n        this.program = program;\n        this.uniforms = {};\n        this.attribs = {};\n\n        const numActiveUniforms = gl.getProgramParameter(\n            program,\n            gl.ACTIVE_UNIFORMS,\n        ) as number;\n        for (let i = 0; i < numActiveUniforms; i++) {\n            const {name} = gl.getActiveUniform(program, i)!;\n            this.uniforms[name] = gl.getUniformLocation(program, name)!;\n        }\n\n        const numActiveAttributes = gl.getProgramParameter(\n            program,\n            gl.ACTIVE_ATTRIBUTES,\n        ) as number;\n        for (let i = 0; i < numActiveAttributes; i++) {\n            const {name} = gl.getActiveAttrib(program, i)!;\n            this.attribs[name] = gl.getAttribLocation(program, name)!;\n        }\n    }\n}\n\nconst attach = (target: HTMLCanvasElement) => {\n    const gl = target.getContext('webgl');\n    if (!gl) return;\n\n    // Initialize vertex buffer. This will draw one 2D quadrilateral.\n    const buffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n\n    // These are 6 points which make up 2 triangles which make up 1 quad/rectangle.\n    gl.bufferData(\n        gl.ARRAY_BUFFER,\n        new Float32Array([\n            0, 0,\n            0, 1,\n            1, 0,\n            1, 1,\n            0, 1,\n            1, 0,\n        ]),\n        gl.STATIC_DRAW,\n    );\n\n    const shader = new Shader(gl, vertexShader, fragmentShader);\n    gl.useProgram(shader.program);\n\n    const attribLocation = shader.attribs.a_position;\n    gl.enableVertexAttribArray(attribLocation);\n    gl.vertexAttribPointer(\n        attribLocation,\n        2,\n        gl.FLOAT,\n        false,\n        0,\n        0,\n    );\n\n    let viewportWidth = -1;\n    let viewportHeight = -1;\n    const ensureViewport = () => {\n        const rect = target.getBoundingClientRect();\n        const width = Math.round(rect.width * window.devicePixelRatio);\n        const height = Math.round(rect.height * window.devicePixelRatio);\n        if (viewportWidth !== width || viewportHeight !== height) {\n            viewportWidth = target.width = width;\n            viewportHeight = target.height = height;\n            gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\n        }\n\n        gl.uniform2f(shader.uniforms.u_resolution, width, height);\n        gl.uniform1f(shader.uniforms.u_dpi, window.devicePixelRatio);\n    };\n\n    const updateColors = (darkMode: boolean) => {\n        if (darkMode) {\n            gl.uniform3f(shader.uniforms.u_darkSquare, 10 / 255, 11 / 255, 18 / 255);\n            gl.uniform3f(shader.uniforms.u_lightSquare, 0.5, 0.05, 0.375);\n        } else {\n            gl.uniform3f(shader.uniforms.u_darkSquare, 0x32 / 255, 0x2d / 255, 0x45 / 255);\n            gl.uniform3f(shader.uniforms.u_lightSquare, 1.0, 0.375, 0.75);\n        }\n    };\n\n    const darkMode = window.matchMedia('(prefers-color-scheme: dark)');\n    darkMode.addEventListener('change', e => {\n        updateColors(e.matches);\n    });\n    updateColors(darkMode.matches);\n\n    const landingContainer = document.getElementById('landing-container');\n    const onFrame = (timestamp: number) => {\n        requestAnimationFrame(onFrame);\n        ensureViewport();\n\n        if ((landingContainer?.clientWidth ?? 0) >= target.clientWidth) {\n            return;\n        }\n\n        gl.uniform1f(shader.uniforms.u_time, timestamp * 0.001);\n        gl.drawArrays(gl.TRIANGLES, 0, 6);\n    };\n    requestAnimationFrame(onFrame);\n};\n\nconst attachToCheckerboard = () => {\n    const target = document.getElementById('checkerboard');\n    if (!target) return;\n    attach(target as HTMLCanvasElement);\n};\n\nif (document.readyState === 'complete') {\n    attachToCheckerboard();\n} else {\n    document.addEventListener('DOMContentLoaded', () => attachToCheckerboard(), {once: true});\n}\n"],
  "mappings": "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",
  "names": ["vertexShader", "fragmentShader", "createShader", "gl", "source", "type", "shader", "info", "Shader", "vertex", "fragment", "program", "numActiveUniforms", "i", "name", "numActiveAttributes", "attach", "target", "buffer", "attribLocation", "viewportWidth", "viewportHeight", "ensureViewport", "rect", "width", "height", "updateColors", "darkMode", "e", "landingContainer", "onFrame", "timestamp", "attachToCheckerboard"]
}
